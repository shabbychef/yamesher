
The software can convert .dat files and xfig .fig files into
meshed .pcmp files, and generates .eps figures along the way.
The simplest way for me to run the software is with the
included makefile. It knows all the flags and how to call
the software. Test this with the included .fig and .dat
files.

	$ make helloworld.pcmp

This should generate a helloworld.pcmp and a bunch of
figures, including

	as_input.ps
	curvature_bounded.ps
	finished_groom.ps
	input_conforming.ps
	quality_insured.ps

These give the state of the mesh at various points in the algorithm.
These figures have been tweaked to be human readable; with just a little
editing of thier headers, one can hide the input or the mesh edges.
Poke a little around in these files.  Edit the following lines

/sho1  {  true } bind def
/sho12 {  true } bind def
/sho2  {  true } bind def
/shocc { false } bind def
/thinl { false } bind def

to change the ps file. 

other information is contained in the ps file, for example the mesh
size, and basic geometry limits:

%num of vertices: 25
%num of    faces: 46
%num of    edges: 69
%%%%%%%%%%%%%%%%%%%%%%%%
%min angle: 0.107709 radians. (6.17126deg)
%max angle: 2.84067 radians. (162.759deg)

FLAGS

Try
	$ make help
to get a listing of the flags for the 

The flags for the software have the prefix LTF_ in the makefile.
they are

	-L 	the iteration limit (maximum number of output vertices)
	-d	the degree limit--essentially the software has lazy lopping. if
				an input angle is less than 2pi/d it will be lopped.
	-g	the factor determining the size of the original corner protecting ball.
				this should be in (0,0.5).  the corner protecting ball will have
				radius gamma times the shortest input edge at the corner.
	-t  the upper limit on total variation.  input with greater
				curvature will automagically be cut down.
	-b	the factor beta from the paper. this is the factor by which
				corner lopped balls are reduced.
	-q	the quality bound, in the form 4 sin^2(kappa), where kappa 
				is the smallest acceptable angle.  Thus use -q 1 for 30 degrees,
				-q 0.5 for 20.07 degrees, etc.
	-C	a simple Chew-mode upper limit on circumradius.  Larger triangles
				will be split.
	-V	the verbosity.  set to 0 for no output from the algorithm.
	-u	a binary flag of whether a `provoker' should be used to split
				input segments.  See the paper for more details.


reasonable values for these are included in the makefile.




