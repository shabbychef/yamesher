//START HEADER
//START COPYRIGHT
/*
 *  Corner Lopping Mesher Software
 *  Copyright (C) 2004 Steven E. Pav
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 *  Send comments and/or bug reports to:
 *                 spav@ucsd.edu 
 */
//END COPYRIGHT
//START CVSLOG
/* CVS info:
 * $Id: lookups.cpp,v 1.23 2005/03/11 02:04:53 spav Exp $
 * $Log: lookups.cpp,v $
 * Revision 1.23  2005/03/11 02:04:53  spav
 * something wrong with cubics?
 *
 * Revision 1.22  2005/02/19 00:02:49  spav
 * looks like cubic bezier is working
 *
 * Revision 1.21  2005/02/15 23:51:54  spav
 * still working on bez_3
 *
 * Revision 1.20  2005/02/12 01:37:16  spav
 * fixed xfig read bug.
 *
 * Revision 1.18  2005/01/26 23:11:46  spav
 * looks good.
 *
 * Revision 1.17  2005/01/18 22:47:11  spav
 * changing provoker to runtime option.
 *
 * Revision 1.16  2005/01/04 23:54:46  spav
 * some tweaks.
 *
 * Revision 1.15  2005/01/03 03:59:54  spav
 * home from san fran.
 *
 * Revision 1.14  2004/12/21 22:42:57  spav
 * looks like it is working; added command line parser.
 *
 * Revision 1.13  2004/12/06 03:54:19  spav
 * added more stuff
 *
 * Revision 1.12  2004/12/02 23:59:35  spav
 * problems with queue ordering...
 *
 * Revision 1.11  2004/12/01 00:02:47  spav
 * seems to work for arcs. start to add bezier.
 *
 * Revision 1.10  2004/11/29 07:05:04  spav
 * post thanksgiving
 *
 * Revision 1.9  2004/11/23 23:43:31  spav
 * appears to work for straight segs. now add arcs, bezier.
 *
 * Revision 1.8  2004/11/23 05:39:02  spav
 * nearly done
 *
 * Revision 1.7  2004/11/23 02:50:36  spav
 * nearly got it...
 *
 * Revision 1.6  2004/11/19 03:01:20  spav
 * still lost
 *
 * Revision 1.5  2004/11/19 02:10:55  spav
 * something odd: an infinite vertex and repeated ballsplitting
 *
 * Revision 1.4  2004/11/04 23:31:25  spav
 * got a running readinput--still cannot hook it up, though.
 *
 * Revision 1.3  2004/11/02 23:51:20  spav
 * checking in.
 *
 * Revision 1.2  2004/10/29 05:26:50  spav
 * pong.
 *
 * Revision 1.1  2004/10/20 21:50:26  spav
 * starting code project
 *
 *
 */
//END CVSLOG
//END HEADER

#include "lookups.h"

#ifndef LOOKUPS_CPP
#define LOOKUPS_CPP

namespace lopping { 

	//gripe_segs//FOLDUP
	template < class DT_2 >
	std::ostream & DT_and_Edge_Table< DT_2 >::gripe_segs(std::ostream& os)
	{
		Flat_Iterator fwalk = seg_data.flatbegin();
		Flat_Iterator fend = seg_data.flatend();

		while (fwalk != fend)
		{
			os << "[ " << (fwalk.first())->point().x() << " " <<
			(fwalk.first())->point().y() << " ]";
			os << " & ";
			os << "[ " << (fwalk.second())->point().x() << " " <<
			(fwalk.second())->point().y() << " ]";
			os << " ===> ";
			os << ((fwalk.third())) << "\n";
			++fwalk;
		}
		return os;
	};//UNFOLD

	//write_ps//FOLDUP
	template < class DT_2 >
	std::ostream & DT_and_Edge_Table< DT_2 >::write_ps(std::ostream& os) 
	{
		Point hold_top = _vtop->point();
		Point hold_lef = _vlef->point();
		Point hold_rig = _vrig->point();

//		Point fake1,fake2;

		remove(_vtop);
		remove(_vlef);
		remove(_vrig);
		_bounding_tri_set = false;

		typedef typename DT_and_Edge_Table::FT FT;
		FT X_BOT(50);
		FT Y_BOT(160);
		FT X_WIDTH(500);
		FT Y_WIDTH(500);

		FT xmin,xmax,ymin,ymax;
		_get_bounding_box(xmin,xmax,ymin,ymax);

		FT xscale = X_WIDTH / (xmax - xmin);
		FT yscale = Y_WIDTH / (ymax - ymin);
		FT pnt_scale = (xscale < yscale)? xscale : yscale;

		FT xoffset = X_BOT - pnt_scale * xmin;
		FT yoffset = Y_BOT - pnt_scale * ymin;

		os << "%%%%%%%%%%%%%%%%%%%%%%%%\n";
		os << "%generated by lookups.cpp\n";
		os << "%%%%%%%%%%%%%%%%%%%%%%%%\n";

		//size of the mesh

		os << "%num of vertices: " << (this->tds().number_of_vertices()) << "\n";
		os << "%num of    faces: " << (this->tds().number_of_faces()) << "\n";
		os << "%num of    edges: " << (this->tds().number_of_edges()) << "\n";

		os << "%%%%%%%%%%%%%%%%%%%%%%%%\n";

		//show off angles of mesh?
		double min_angle,max_angle;
		find_min_max_angles(min_angle,max_angle);

		os << "%min angle: " << min_angle << " radians. (" << 
			(min_angle * 180.0 / lopping::PI) << "deg)\n";
		os << "%max angle: " << max_angle << " radians. (" << 
			(max_angle * 180.0 / lopping::PI) << "deg)\n";
		os << "%%%%%%%%%%%%%%%%%%%%%%%%\n";

		//show off angles of mesh?

		os <<
"%in general 1 refers to the 1-d input curves as themselves\n\
%           12 refers to the input curves as represented as mesh edges\n\
%           2 refers to non-input mesh edges\n\
%whether to show the 1skel,12skel,2skel,circumcenters\n\
/sho1  {  true } bind def\n\
/sho12 {  true } bind def\n\
/sho2  {  true } bind def\n\
/shocc { false } bind def\n\
/thinl { false } bind def\n";

		os << "%%%%%%%%%%%%%%%%%%%%%%%%\n% line widths & colors \n%%%%%%%%%%%%%%%%%%%%%%%%\n";

		os << "/pscale { " << lopping::FT2double< Kernel >(pnt_scale) << " } def\n";

		os <<
"/pntsz1 { thinl {0.005} {1.445} ifelse pscale div } def\n\
/pntsz2 { thinl {0.010} {0.055} ifelse pscale div } def\n\
/linwt1 { thinl {0.015} {1.105} ifelse pscale div } def\n\
/linwt12 { thinl {0.005} {0.305} ifelse pscale div } def\n\
/linwt2 { thinl {0.005} {0.005} ifelse pscale div } def\n\
/linwtc { thinl {0.005} {0.005} ifelse pscale div } def\n";
		
		os << "%%%%%%%%%%%%%%%%%%%%%%%%\n% coordinate system \n%%%%%%%%%%%%%%%%%%%%%%%%\n";

		os << lopping::FT2double< Kernel >(xoffset) << " " << 
		      lopping::FT2double< Kernel >(yoffset) << " translate\n";
		os << lopping::FT2double< Kernel >(pnt_scale) << " " <<
		      lopping::FT2double< Kernel >(pnt_scale) << " scale\n";

//old way
//plin { 2 copy p1 linwt1 setlinewidth newpath moveto lineto currentpoint stroke p1 } def

		os <<
"1 setlinecap\n\
1 setlinejoin\n\
%%%%%%%%%%%%%%%%%%%%%%%%\n% misc \n%%%%%%%%%%%%%%%%%%%%%%%%\n\
% p q lambda linc -- linear combination (1-lambda) p + q lambda\n\
/linc { dup 3 1 roll mul 3 1 roll 1 exch sub mul add } def\n\
% x0 y0 x1 y1 lambda linc2 -- linear combination of (x0,y0), (x1,y1)\n\
/linc2 { dup 6 5 roll 5 4 roll 3 2 roll linc 4 1 roll linc } def\n\
%%%%%%%%%%%%%%%%%%%%%%%%\n% points \n%%%%%%%%%%%%%%%%%%%%%%%%\n\
% x y p(1|2)\n\
/p1 { sho1 {newpath pntsz1 0 360 arc closepath fill} { pop pop } ifelse } def\n\
/p2 { sho2 {newpath pntsz2 0 360 arc closepath fill} { pop pop } ifelse } def\n\
% x0 y0 x1 y1 pp(1|2)\n\
/pp1 { p1 p1 } def\n\
/pp2 { p2 p2 } def\n\
/mcp1 { moveto currentpoint p1 } bind def\n\
%%%%%%%%%%%%%%%%%%%%%%%%\n% 1 stuff\n%%%%%%%%%%%%%%%%%%%%%%%%\n\
% x0 y0 x1 y1 [p]lin1\n\
/lin1 { sho1 {linwt1 setlinewidth newpath moveto lineto stroke} { 4 {pop} repeat } ifelse} def\n\
/plin1 { sho1 {4 copy pp1 lin1} { 4 {pop} repeat } ifelse} def\n\
%unknown\n\
/qcvto { linwt1 setlinewidth newpath moveto currentpoint stxy lineto currentpoint stroke p1 gtxy p1 } def\n\
% x0 y0 x1 y1 x2 y2 qbez -- outputs cubic bezier form of quadratic bezier\n\
/qbez { 6 4 roll 2 copy 8 6 roll 2 copy 6 2 roll 2.0 3.0 div linc2 8 6 roll 2 copy 8 6 roll 2.0 3.0 div linc2 4 2 roll } def\n\
% cx cy rad theta0 theta1 x0 y0 x1 y1 ac[c]w1\n\
/acw1 { sho1 {mcp1 mcp1 linwt1 setlinewidth arcn stroke} {9 {pop} repeat} ifelse } def\n\
/accw1 { sho1 {mcp1 mcp1 linwt1 setlinewidth arc stroke} {9 {pop} repeat} ifelse } def\n\
% x0 y0 x1 y1 x2 y2 x3 y3 cbez1 -- plot cubic bezier\n\
/cbez1 { sho1 {2 copy p1 8 6 roll 2 copy p1 linwt1 setlinewidth newpath moveto curveto stroke} {8 {pop} repeat} ifelse} def\n\
% x0 y0 x1 y1 x2 y2 qbez1 -- plot quadratic bezier\n\
/qbez1 { sho1 {qbez cbez1} {6 {pop} repeat} ifelse} def\n\
%%%%%%%%%%%%%%%%%%%%%%%%\n% 2 stuff\n%%%%%%%%%%%%%%%%%%%%%%%%\n\
% x0 y0 x1 y1 [p]lin2\n\
/lin2 { sho2 {linwt2 setlinewidth newpath moveto lineto stroke} {4 {pop} repeat} ifelse } def\n\
/plin2 { sho2 {4 copy pp2 lin2} {4 {pop} repeat} ifelse } def\n\
% x0 y0 x1 y1 [p]lin12\n\
%%%%%%%%%%%%%%%%%%%%%%%%\n% 12 stuff\n%%%%%%%%%%%%%%%%%%%%%%%%\n\
/lin12 { sho12 {linwt12 setlinewidth newpath moveto lineto stroke} {4 {pop} repeat} ifelse} def\n\
/plin12 { sho12 {4 copy pp2 lin12} {4 {pop} repeat} ifelse } def\n\
% xc yc r crcl\n\
%%%%%%%%%%%%%%%%%%%%%%%%\n% circumcircles \n%%%%%%%%%%%%%%%%%%%%%%%%\n\
/crcl { newpath 0 360 arc closepath stroke } def\n\
%serious math\n\
%a c b d dtmt -- determinant by columns\n\
/dtmt { 4 3 roll mul 3 1 roll mul sub } def\n\
%a c b d e f ksolv -- solve linear system by cramer's rule\n\
/ksolv { 6 2 roll 4 copy dtmt dup 8 6 roll 2 copy 10 8 roll 4 2 roll dtmt 3 1 roll 7 5 roll dtmt 4 3 roll div 3 1 roll 2 1 roll div } def\n\
%x0 x1 x2 ccsetup -- set up circumcenter solve, spit out x1-x0,x2-x0,(x1-x0)^2,(x2-x0)^2\n\
/ccsetup { 3 2 roll dup 3 1 roll sub 3 1 roll sub dup dup mul 3 2 roll dup dup mul 3 2 roll exch } def\n\
%x0 x1 x2 y0 y1 y2 dblsetup -- set up circumcenter solve for x&y\n\
/dblsetup { ccsetup 7 4 roll ccsetup 8 4 roll 6 4 roll 3 2 roll add 0.5 mul 3 1 roll add 0.5 mul exch } def\n\
%x0 y0 x1 y1 x2 y2 findcc -- find the circumcenter as x,y\n\
/findcc { 5 4 roll 4 3 roll 3 2 roll dblsetup ksolv } def\n\
%x0 y0 x1 y1 x2 y2 plotcc -- plot the circumcenter\n\
/plotcc { shocc {6 4 roll 2 copy 8 4 roll findcc 2 copy dup mul exch dup mul add sqrt 5 1 roll 3 2 roll add 3 1 roll add exch 3 2 roll crcl} {6 {pop} repeat} ifelse } def\n\
%%%%%%%%%%%%%%%%%%%%%%%%\n% colors \n%%%%%%%%%%%%%%%%%%%%%%%%\n\
/setc { aload pop setrgbcolor } bind def\n\
/col1 { [1 0 0] setc } def\n\
/col2 { [0 0 0] setc } def\n\
/col3 { [0 1 0] setc } def\n\
/colc { [0 1 1] setc } def\n\
%%%%%%%%%%%%%%%%%%%%%%%%\n% input 'segments'\n%%%%%%%%%%%%%%%%%%%%%%%%\n";

		os << "linwt1 setlinewidth col1\n";

		//get the segments
		
		Increasing_Flat_Iterator fwalk = seg_data.increasingflatbegin();
		Increasing_Flat_Iterator fend = seg_data.increasingflatend();

		FT ps_angle_cvrter = FT(180 / lopping::PI);

		while (fwalk != fend)
		{
			switch ( (*(fwalk.third())).styp ) {
			case Segment_wrapper::STRAIGHT :  
				os << ((fwalk.first())->point().x()) << " " <<
					    ((fwalk.first())->point().y()) << " " <<
				      ((fwalk.second())->point().x()) << " " <<
					    ((fwalk.second())->point().y()) << " " <<
							"plin1\n";
				break;
			case Segment_wrapper::ARC :  
				os
					<< ((fwalk.third())->arc)->center.x() << " " 
					<< ((fwalk.third())->arc)->center.y() << " " 
					<< ((fwalk.third())->arc)->radius() << " " 
					<< ((ps_angle_cvrter) * ((fwalk.third())->arc)->start_angle()) << " " 
					<< ((ps_angle_cvrter) * ((fwalk.third())->arc)->end_angle())   << " " 
//					<<	((ps_angle_cvrter) * 
//							 ( ((fwalk.third())->arc)->end_angle()
//							 - ((fwalk.third())->arc)->start_angle() ) ) << " " 
				  << ((fwalk.second())->point().x()) << " " 
					<< ((fwalk.second())->point().y()) << " " 
					<< ((fwalk.first())->point().x()) << " " 
					<< ((fwalk.first())->point().y()) << " " ;

				os <<  ( (((fwalk.third())->arc)->is_cw)? "acw1\n":"accw1\n" );
				break;
			case Segment_wrapper::BEZIER_2 :  

//				fake1 = 
//					lopping::linear_combination< Kernel >( 
//											((fwalk.third())->bezier_2)->p1,
//											((fwalk.third())->bezier_2)->p15, FT(2.0/3.0) );
//
//				fake2 = 
//					lopping::linear_combination< Kernel >( 
//											((fwalk.third())->bezier_2)->p2,
//											((fwalk.third())->bezier_2)->p15, FT(2.0/3.0) );

//				GRIPE("bez2: \n");
//				GRIPEP( ((fwalk.third())->bezier_2)->p1 );
//				GRIPEP( ((fwalk.third())->bezier_2)->p15 );
//				GRIPEP( ((fwalk.third())->bezier_2)->p2 );
//				GRIPE("fake1: \n");
//				GRIPEP(fake1);
//				GRIPE("fake2: \n");
//				GRIPEP(fake2);

//				os
//					<< ((fwalk.third())->bezier_2)->p1.x() << " " 
//					<< ((fwalk.third())->bezier_2)->p1.y() << " " 
//					<< fake1.x() << " " 
//					<< fake1.y() << " " 
//					<< fake2.x() << " " 
//					<< fake2.y() << " " 
//					<< ((fwalk.third())->bezier_2)->p2.x() << " " 
//					<< ((fwalk.third())->bezier_2)->p2.y() << " cbez1\n";

				os
					<< ((fwalk.third())->bezier_2)->p1.x() << " " 
					<< ((fwalk.third())->bezier_2)->p1.y() << " " 
					<< ((fwalk.third())->bezier_2)->p15.x() << " " 
					<< ((fwalk.third())->bezier_2)->p15.y() << " " 
					<< ((fwalk.third())->bezier_2)->p2.x() << " " 
					<< ((fwalk.third())->bezier_2)->p2.y() << " qbez1\n";
				break;
			case Segment_wrapper::BEZIER_3 :  
				os
					<< ((fwalk.third())->bezier_3)->p1.x() << " " 
					<< ((fwalk.third())->bezier_3)->p1.y() << " " 
					<< ((fwalk.third())->bezier_3)->p133.x() << " " 
					<< ((fwalk.third())->bezier_3)->p133.y() << " " 
					<< ((fwalk.third())->bezier_3)->p166.x() << " " 
					<< ((fwalk.third())->bezier_3)->p166.y() << " " 
					<< ((fwalk.third())->bezier_3)->p2.x() << " " 
					<< ((fwalk.third())->bezier_3)->p2.y() << " cbez1\n";
				break;
			default : break; } 
			++fwalk;
		}

		os << "%%%%%%%%%%%%%%%%%%%%%%%%\n% mesh edges \n%%%%%%%%%%%%%%%%%%%%%%%%\n";
		os << "linwt2 setlinewidth col2\n";

		//now get all the edges
		//
		typename DT_2::Finite_edges_iterator edge_walker = finite_edges_begin();
		typename DT_2::Finite_edges_iterator edge_end = finite_edges_end();

		Vertex_handle v1,v2;

		while (edge_walker != edge_end)
		{
			v1 = (*((*edge_walker).first)).vertex(cw( (*edge_walker).second ));
			v2 = (*((*edge_walker).first)).vertex(ccw( (*edge_walker).second ));

			if (!(touches_bounding_tri(v1) || touches_bounding_tri(v2)))
			{
				os << (*v1).point().x() << " " << (*v1).point().y() << " " <<
			      (*v2).point().x() << " " << (*v2).point().y();
				
				os << ((has_segment(v1,v2))? " plin12\n" : " plin2\n" );
			}
			++edge_walker;
		}

		os << "%%%%%%%%%%%%%%%%%%%%%%%%\n% circumcenters \n%%%%%%%%%%%%%%%%%%%%%%%%\n";
		os << "linwtc setlinewidth colc\n";

		//now draw the cc's
		typename DT_2::Finite_faces_iterator face_walker = finite_faces_begin();
		typename DT_2::Finite_faces_iterator face_end = finite_faces_end();

//		Point thecc;
//		FT cradsq;
//
//		while (face_walker != face_end)
//		{
//			thecc = (circumcenter(face_walker));
//			cradsq = CGAL::squared_distance( (*((*face_walker).vertex(0))).point() , thecc ); 
//
//			os << thecc.x() << " " << thecc.y() << " " 
//				<< lopping::sqrtFT< Kernel >( cradsq ) << " crcl\n";
//			++face_walker;
//		}

		while (face_walker != face_end)
		{
			os << 
				(*((*face_walker).vertex(0))).point().x() << " " <<
				(*((*face_walker).vertex(0))).point().y() << " " <<
				(*((*face_walker).vertex(1))).point().x() << " " <<
				(*((*face_walker).vertex(1))).point().y() << " " <<
				(*((*face_walker).vertex(2))).point().x() << " " <<
				(*((*face_walker).vertex(2))).point().y() << " " <<
				" plotcc\n";
			++face_walker;
		}

		os << "showpage\n";

		_vtop = insert(hold_top);
		_vlef = insert(hold_lef);
		_vrig = insert(hold_rig);
		_bounding_tri_set = true;

		return os;

	};//UNFOLD

	//write_pcmp//FOLDUP
	//format for a pcmp file:
	//#comments
	//(embedded_dim)
	//#a polytope
	//(p1 #simps) (p1 verts/simp) (p1 #fields) [(p1 name) (p1 data)]
	//simp1v1 simp1v2 ... simp1vk   simp1dat1 simp1dat2 ... simp1datl
	//simp2v1 simp2v2 ... simp2vk   simp2dat1 simp2dat2 ... simp2datl
	//...
	//simpnv1 simpnv2 ... simpnvk   simpndat1 simpndat2 ... simpndatl
	//#a vertex
	//0 vname vcoord1 vcoord2 ... vcoordembdim
	//#vertices may be between polytope records.
	//(p2 #simps) (p2 verts/simp) (p2 #fields) [(p2 name) (p2 data)]
	//simp1v1 simp1v2 ... simp1vk   simp1dat1 simp1dat2 ... simp1datl
	//simp2v1 simp2v2 ... simp2vk   simp2dat1 simp2dat2 ... simp2datl
	//...
	//simpnv1 simpnv2 ... simpnvk   simpndat1 simpndat2 ... simpndatl
	//0 vname vcoord1 vcoord2 ... vcoordembdim
	//0 vname vcoord1 vcoord2 ... vcoordembdim
	//# etc
	template < class DT_2 >
		std::ostream & DT_and_Edge_Table< DT_2 >::write_pcmp(std::ostream& os)
	{
		Point hold_top = _vtop->point();
		Point hold_lef = _vlef->point();
		Point hold_rig = _vrig->point();

		remove(_vtop);
		remove(_vlef);
		remove(_vrig);

		os << "#generated by lookups.cpp\n#dim:\n2\n";

		typename DT_2::Finite_vertices_iterator walk_v = finite_vertices_begin();
		typename DT_2::Finite_vertices_iterator end_v = finite_vertices_end();

		while (walk_v != end_v)
		{
			os << "0 " << &(*walk_v) << " " << 
				(*walk_v).point().x() << " " << 
				(*walk_v).point().y() << "\n";
			++walk_v;
		}

		//get the segments
		Increasing_Flat_Iterator fwalk = seg_data.increasingflatbegin();
		Increasing_Flat_Iterator fend = seg_data.increasingflatend();
		int edge_num = 1;

		while (fwalk != fend)
		{
			os << "1 2 0 edge_" << ++edge_num << "\n";
			os << &(*(fwalk.first())) << " " << &(*(fwalk.second())) << "\n";
			++fwalk;
		}

		//now get all the faces
		typename DT_2::Finite_faces_iterator face_walker = finite_faces_begin();
		typename DT_2::Finite_faces_iterator face_end = finite_faces_end();

		os << number_of_faces() << " 3 0 planarmesh\n";
		while (face_walker != face_end)
		{
			os << 
				&(*((*face_walker).vertex(0))) << " " <<
				&(*((*face_walker).vertex(1))) << " " <<
				&(*((*face_walker).vertex(2))) << "\n";
			++face_walker;
		}

		_vtop = insert(hold_top);
		_vlef = insert(hold_lef);
		_vrig = insert(hold_rig);

		return os;
	};//UNFOLD

	//get the bounding box of the triangulation;//FOLDUP
	//assumes there is no bounding triangle;
	template < class DT_2 >
	void DT_and_Edge_Table< DT_2 >::_get_bounding_box(FT &xmin,FT &xmax,FT &ymin,FT &ymax)
	{
		typename DT_2::Vertex_circulator chull_walker = 
			incident_vertices(infinite_vertex());
		typename DT_2::Vertex_circulator chull_walker_start = chull_walker;

		typedef typename DT_and_Edge_Table::FT FT;

		xmin = (*chull_walker).point().x();
		xmax = (*chull_walker).point().x();
		ymin = (*chull_walker).point().y();
		ymax = (*chull_walker).point().y();

		while (++chull_walker != chull_walker_start)
		{
			if ((*chull_walker).point().x() < xmin)
			{ xmin = (*chull_walker).point().x(); }
			if ((*chull_walker).point().x() > xmax)
			{ xmax = (*chull_walker).point().x(); }

			if ((*chull_walker).point().y() < ymin)
			{ ymin = (*chull_walker).point().y(); }
			if ((*chull_walker).point().y() > ymax)
			{ ymax = (*chull_walker).point().y(); }
		}
	};//UNFOLD

	//get the center and radius of circle which encloses the//FOLDUP
	//bounding box.
	template < class DT_2 >
	void DT_and_Edge_Table< DT_2 >::_get_bbox_center(FT &xc,FT &yc,FT &rad)
	{
		typedef typename DT_and_Edge_Table::FT FT;

		FT xmin,xmax,ymin,ymax;
		_get_bounding_box(xmin,xmax,ymin,ymax);
		xc = (xmin + xmax) / FT(2.0);
		yc = (ymin + ymax) / FT(2.0);
		FT xrad = (xmax - xmin) / FT(2.0);
		FT yrad = (ymax - ymin) / FT(2.0);

		rad = lopping::sqrtFT< Kernel >( (xrad*xrad + yrad*yrad) );
	};//UNFOLD

	//ensure the convex hull are segments or add a bounding box.//FOLDUP
	//return true if the chull are segs.
	template < class DT_2 >
	bool DT_and_Edge_Table< DT_2 >::ensure_chull_are_segs(void)
	{
		bool found_non_edge = false;

		typename DT_2::Vertex_circulator next_vtx = 
			incident_vertices(infinite_vertex());
		typename DT_2::Vertex_circulator vtx_start = next_vtx;

		Vertex_handle prev_vtx = next_vtx;

		while ((++next_vtx != vtx_start) && !found_non_edge)
		{
			found_non_edge = !(has_segment(prev_vtx,next_vtx));
			prev_vtx = next_vtx;
		}

		if (found_non_edge) //add bounding box//FOLDUP
		{
			CARP( GRIPE_INFO, "not all chull edges are segments\n")
			CARP( GRIPE_INFO, "adding bounding segments\n")
			typedef typename DT_and_Edge_Table::FT FT;
			FT xmin,xmax,ymin,ymax;
			_get_bounding_box(xmin,xmax,ymin,ymax);

			FT xc,yc,xrad,yrad;
			xc = (xmin + xmax) / FT(2.0);
			yc = (ymin + ymax) / FT(2.0);
			xrad = (xmax - xmin) / FT(2.0);
			yrad = (ymax - ymin) / FT(2.0);

			xrad = xrad * FT(LOOKUPS_BOUNDING_BOX_EXPANSION_FACTOR);
			yrad = yrad * FT(LOOKUPS_BOUNDING_BOX_EXPANSION_FACTOR);

			xmin = xc - xrad; xmax = xc + xrad;
			ymin = yc - yrad; ymax = yc + yrad;

			Point low_lef(xmin,ymin);
			Point low_rig(xmax,ymin);
			Point upp_lef(xmin,ymax);
			Point upp_rig(xmax,ymax);

			Vertex_handle v_low_lef = insert(low_lef);
			Vertex_handle v_low_rig = insert(low_rig);
			Vertex_handle v_upp_lef = insert(upp_lef);
			Vertex_handle v_upp_rig = insert(upp_rig);

			Segment_handle a_seg;
			a_seg = new Segment_wrapper(low_lef,low_rig);
			insert_segment(v_low_lef,v_low_rig,a_seg);

			a_seg = new Segment_wrapper(upp_lef,upp_rig);
			insert_segment(v_upp_lef,v_upp_rig,a_seg);

			a_seg = new Segment_wrapper(low_lef,upp_lef);
			insert_segment(v_low_lef,v_upp_lef,a_seg);

			a_seg = new Segment_wrapper(low_rig,upp_rig);
			insert_segment(v_low_rig,v_upp_rig,a_seg);
			return false;
		}//UNFOLD
		//else:
		CARP( GRIPE_INFO, "all chull edges are segments\n")
		return true;
	};//UNFOLD

	//nn_squared//FOLDUP
	template < class DT_2 >
	typename DT_and_Edge_Table< DT_2 >::FT 
		DT_and_Edge_Table< DT_2 >::nn_squared(const Vertex_handle &vtx)
	{
		typedef typename DT_and_Edge_Table::FT FT;
		FT min_squared_distance;
		FT compare_squared_distance;
	
		typename Tds::Vertex_circulator neighbor_vertex = incident_vertices(vtx);
		typename Tds::Vertex_circulator start_vertex = neighbor_vertex;

		Point this_p = (*vtx).point();

		min_squared_distance = 
				( (*neighbor_vertex)->point() - this_p ) *
				( (*neighbor_vertex)->point() - this_p );

		while (++neighbor_vertex != start_vertex)
		{
			compare_squared_distance = 
				( (*neighbor_vertex)->point() - this_p ) *
				( (*neighbor_vertex)->point() - this_p );
			if (compare_squared_distance < min_squared_distance)
				{ min_squared_distance = compare_squared_distance; }
		}
		return min_squared_distance;
	};//UNFOLD

	//find the maximum and minimum angles in the mesh.//FOLDUP
	template < class DT_2 >
		void
		DT_and_Edge_Table< DT_2 >::find_min_max_angles(double &min_angle,double &max_angle)
	{
		double min_deg = lopping::PI;
		double max_deg = 0.0;
		double or_min_deg,or_max_deg;

		typename DT_2::Finite_faces_iterator face_walker = finite_faces_begin();
		typename DT_2::Finite_faces_iterator face_end = finite_faces_end();

		Vertex_handle v0,v1,v2;

		while (face_walker != face_end)
		{
			v0 = (*face_walker).vertex(0);
			v1 = (*face_walker).vertex(1);
			v2 = (*face_walker).vertex(2);

			if (!(touches_bounding_tri(v0) || 
						touches_bounding_tri(v1) || 
						touches_bounding_tri(v2)))
			{
				if (lopping::min_max_angle< Kernel >(or_min_deg,or_max_deg,
																	 v0->point(),v1->point(),v2->point()))
				{ //is degenerate
				} else
				{
					CARP( GRIPE_INFO, "min: " << min_deg << " max: " << max_deg << "\n" )

					if (or_min_deg < min_deg)
					{ min_deg = or_min_deg; }
					if (or_max_deg > max_deg)
					{ max_deg = or_max_deg; }
				}
			}
			++face_walker;
		}
		min_angle = min_deg;
		max_angle = max_deg;
	};//UNFOLD

	//add_bounding_tri//FOLDUP
	template < class DT_2 >
		void DT_and_Edge_Table< DT_2 >::add_bounding_tri(void)
	{
		typedef typename DT_and_Edge_Table::FT FT;
		FT xbar,ybar,rad;
		_get_bbox_center(xbar,ybar,rad);
		
		Point pcenter(xbar,ybar);

		//FIX: might need fixed;
		//1.1 is for safety
		rad = rad * FT(1.1);

		Point btop(xbar,ybar + (rad * FT(2.0)));
		Point blef(xbar - (rad * FT(sqrt(3.0))),ybar - rad);
		Point brig(xbar + (rad * FT(sqrt(3.0))),ybar - rad);

		_vtop = insert(btop);
		_vlef = insert(blef);
		_vrig = insert(brig);
		_bounding_tri_set = true;
	};//UNFOLD

	//touches_bounding_tri//FOLDUP
	template < class DT_2 >
		bool DT_and_Edge_Table< DT_2 >::touches_bounding_tri(const Face_handle &a_face)
	{
		return 
			( (touches_bounding_tri(a_face->vertex(0))) ||
			  (touches_bounding_tri(a_face->vertex(1))) ||
			  (touches_bounding_tri(a_face->vertex(2))) );
	};//UNFOLD

	//is_inside_bounding_tri//FOLDUP
	template < class DT_2 >
		bool DT_and_Edge_Table< DT_2 >::is_inside_bounding_tri(const Point &check_point)
	{
		typename Kernel::Triangle_2 checkt (_vtop->point(),_vlef->point(),_vrig->point());
		return (checkt.bounded_side(check_point) == CGAL::ON_BOUNDED_SIDE);
	};//UNFOLD
} 

#endif //LOOKUPS_CPP
